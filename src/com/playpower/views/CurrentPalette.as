package com.playpower.views{	import flash.display.Sprite;	import flash.display.Graphics;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.text.TextField;	import flash.utils.ByteArray;	import com.carlcalderon.arthropod.Debug;	import com.playpower.core.*;	import com.playpower.events.CustomEvent;	import com.playpower.ui.PP_CurTileButton;	public class CurrentPalette extends Sprite	{		private var _controller:Controller;		private var _tileArr:Array;		private var _outline:Sprite;		private var _tileOutline:Sprite;		private var _outlineWidth:Number;		private var _byteArray:ByteArray;		private var _curTile:Number = 0;		private var _label:TextField;		private var _hexDisplay:Boolean = true;				public function CurrentPalette()		{			_controller = Controller.getInstance();						this.addEventListener(Event.ADDED_TO_STAGE, _onAddedToStage, false, 0, true);		}		private function _onAddedToStage($e:Event):void		{			this.removeEventListener(Event.ADDED_TO_STAGE, _onAddedToStage);						_outlineWidth = Constants.BUTTON_DIMS*4;						_byteArray = new ByteArray();			_tileArr = [];			for(var i=0; i<(Constants.CUR_PALETTE_WIDTH/Constants.BUTTON_DIMS); i++)			{				// figure the y based on where we are in the loop				var tile:PP_CurTileButton = new PP_CurTileButton("00",i);				_byteArray.writeByte(00);				tile.addEventListener(CustomEvent.BUTTON_UP, _onTileUp, false, 0, true);				tile.x = i*Constants.BUTTON_DIMS;								this.addChild(tile);				_tileArr.push(tile);			}						_outline = new Sprite();			var g:Graphics = _outline.graphics;			g.lineStyle(2,0x000000);			g.drawRect(0,0,_outlineWidth,Constants.BUTTON_DIMS);			this.addChild(_outline);						_tileOutline = new Sprite();			var g2:Graphics = _tileOutline.graphics;			g2.lineStyle(2,0xFF0000);			g2.drawRect(0,0,Constants.BUTTON_DIMS,Constants.BUTTON_DIMS);			this.addChild(_tileOutline);						_label = CustomTextField.getTextField("",0x000000,12);			_label.y = -1*Constants.GUTTER_WIDTH*1.25;			this.addChild(_label);		}				public function get theByteArray():ByteArray		{			return _byteArray;		}				public function set theByteArray(a:ByteArray):void		{			_byteArray = a;		}				public function get byteArray():ByteArray		{			return _byteArray;		}				public function get curTile():Number		{			return _curTile;		}				public function set curTile(n:Number):void		{			_curTile = n;		}				public function get curColor():String		{			var t:PP_CurTileButton = _tileArr[_curTile] as PP_CurTileButton;						return t.clr;		}				public function set curColor(s:String):void		{			var t:PP_CurTileButton = _tileArr[_curTile] as PP_CurTileButton;						t.clr = s;		}				public function get hexDisplay():Boolean		{			return _hexDisplay;		}				public function get selectedPal():Number // returns the current position of _outline		{			var pct:Number = (_outline.x+64)/this.width;			return Math.floor(pct*4);		}				public function set selectedPal(n:Number):void		{			_outline.x = this.width/n;		}				public function setPalette(arr:ByteArray):void		{			_byteArray = arr;			for(var i=0; i<_byteArray.length; i++)			{				// convert byte >> hex				var n:String = _byteArray[i].toString(16).toUpperCase();				if(n.length < 2) n = "0"+n;				var t:PP_CurTileButton = _tileArr[i] as PP_CurTileButton;				t.update(n);			}						// move outline as needed			_outline.x = _controller.curAttr * 64;		}				public function updateTiles(clr:String, startTile:Number,tileIncr:Number)		{			for(var i=startTile; i<_tileArr.length; i+=tileIncr)			{				_byteArray[i] = hex2dec(clr);				var t:PP_CurTileButton = _tileArr[i] as PP_CurTileButton;				t.update(clr);			}		}				public function updateCurrentTile(clr:String)		{			_byteArray[_curTile] = hex2dec(clr);			var t:PP_CurTileButton = _tileArr[_curTile] as PP_CurTileButton;			t.update(clr);		}				public function toggleHexDisplay():void		{			for(var i=0; i<_tileArr.length; i++)			{				var tile:PP_CurTileButton = _tileArr[i] as PP_CurTileButton;				tile.toggleString();			}						_hexDisplay = !_hexDisplay;		}				public function hex2dec( hex:String ) : String {			var bytes:Array = [];			bytes.splice( 0, 0, int("0x"+hex) );			return bytes.join(" ");		}				public function setLabel(str:String):void		{			_label.text = str;		}				private function _onTileUp($e:CustomEvent):void		{			_curTile = $e.objInfo.id;						var tile:PP_CurTileButton = $e.currentTarget as PP_CurTileButton;						// show a red outline around the selected tile			_tileOutline.x = tile.x;						// make sure the white tile outline starts from the first of four tiles in the block			if(tile.x%_outlineWidth == 0)			{				_outline.x = tile.x;			}			else			{				_outline.x = tile.x - (tile.x%_outlineWidth);			}						dispatchEvent( $e );		}				public function destroy():void		{			for(var i=0; i<_tileArr.length; i++)			{				var tile:PP_CurTileButton = _tileArr[i] as PP_CurTileButton;				this.removeChild(tile);				tile.removeEventListener(CustomEvent.BUTTON_UP, _onTileUp);				tile.destroy();				tile = null;			}			_tileArr = [];			_controller = null;			this.removeChild(_outline);			_outline = null;			this.removeChild(_tileOutline);			_tileOutline = null;		}	}}