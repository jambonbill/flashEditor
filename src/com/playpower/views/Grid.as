package com.playpower.views{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.text.TextField;	import flash.utils.ByteArray;	import flash.utils.Timer;	import com.carlcalderon.arthropod.Debug;	import com.playpower.core.*;	import com.playpower.events.CustomEvent;	import com.playpower.ui.OutlineButton;	public class Grid extends Sprite	{		public var _controller:Controller;		public var _w:Number;		public var _h:Number;		private var _bg:Bitmap;		private var _bmd:BitmapData;		private var _lines:Sprite;		private var _btns:Sprite;		private var _btnArr:Array;		private var _background:Sprite;		private var _label:TextField;		private var _flag:int = 0;				// have no idea why these were continually reset. they are stored in the singleton for now		//private var _selectedTile:Number = 120;		//private var _curAttr:Number;				private var _padding:int = 5;				public var _palArr:ByteArray;		public var _chrArr:ByteArray;		public var _namArr:ByteArray;		private var _dragTimer:Timer;		/* BIT MATH		 0 + 0 = 0		 1 + 0 = 1		 0 + 1 = 2		 1 + 1 = 3 		 		 HAVE TO READ ONE BIT FROM EACH BIT PLANES AND USE ABOVE FORMULA		 TO CALC THE VALUE		 		 TAKE FIRST ARRAY VALUE + OFFSET OVER BY 8 TO GET SECOND VALUE		 ADD THESE TWO VALUES TOGETHER TO GET FINAL VAL		 */				public function Grid(w:Number,h:Number)		{			_w = w;			_h = h;						_controller = Controller.getInstance();			_btnArr = new Array();						_dragTimer = new Timer(10);			_dragTimer.addEventListener(TimerEvent.TIMER, _onDragTimer, false, 0, true);						_palArr = new ByteArray();			_chrArr = new ByteArray();			_namArr = new ByteArray();						this.addEventListener(KeyboardEvent.KEY_DOWN, _onKeyDown, false, 0, true);			this.addEventListener(KeyboardEvent.KEY_UP, _onKeyUp, false, 0, true);			this.addEventListener(Event.ADDED_TO_STAGE, _onAddedToStage, false, 0, true);		}		public function _onAddedToStage($e:Event):void		{			this.removeEventListener(Event.ADDED_TO_STAGE, _onAddedToStage);						_background = new Sprite();			var g:Graphics = _background.graphics;			g.beginFill(0xFFFFFF);			g.drawRect(-_padding,-_padding,_w+(_padding*2),_h+(_padding*2));			g.endFill();			this.addChild(_background);				// DRAW GRIDS (BOTH NAM & CHR)			if(_controller.gridEnabled)			{				_bmd = new BitmapData(_w,_h,false,Constants.CLR_00);				_bg = new Bitmap(_bmd);				this.addChild(_bg);				//_bg.x = _bg.y = _padding;								_lines = new Sprite();				this.addChild(_lines);				//_lines.x = _lines.y = _padding;				var c:int = 0;				for(var i=0; i<_w+Constants.GUTTER_WIDTH; i+=Constants.GUTTER_WIDTH)				{					if(i <= _h)					{						// draw x-axis						var xLineClr:Number;						c%2 ? xLineClr = Constants.GRID_CLR2 : xLineClr = Constants.GRID_CLR;						var x_axis:Sprite = new Sprite();						var x_axis_g:Graphics = x_axis.graphics;						x_axis_g.lineStyle(1, xLineClr, 1);						x_axis_g.moveTo(0,i);						x_axis_g.lineTo(_w,i);						_lines.addChild(x_axis);					}										// draw y-axis					var yLineClr:Number;					c%2 ? yLineClr = Constants.GRID_CLR2 : yLineClr = Constants.GRID_CLR;					var y_axis:Sprite = new Sprite();					var y_axis_g:Graphics = y_axis.graphics;					y_axis_g.lineStyle(1, yLineClr, 1);					y_axis_g.moveTo(i,0);					y_axis_g.lineTo(i,_h);					_lines.addChild(y_axis);										c++;				}								var yy:Number = 0;				var xx:Number = 0;				_btns = new Sprite();				this.addChild(_btns);				for(var k=0; k<Math.pow(_w/Constants.BUTTON_DIMS,2); k++)				{					// place invisible buttons across grid					if(yy < _h)					{						var btn:OutlineButton = new OutlineButton();						btn.init(k.toString(),Constants.BUTTON_DIMS,Constants.BUTTON_DIMS);												// we don't want the small grid to have the mouse down function						if(_w > 256) 						{							btn.addEventListener(MouseEvent.MOUSE_DOWN, _onMouseDown, false, 0, true);						}						btn.addEventListener(MouseEvent.MOUSE_UP, _onMouseUp, false, 0, true);												if ( (k*Constants.BUTTON_DIMS)%_w == 0 && k!=0 ) 						{							xx = 0;							yy += Constants.BUTTON_DIMS;														// keeps from rendering a widowed button tile on a line below the grid							if(yy == _h) break;						}						btn.x = xx*Constants.BUTTON_DIMS;						btn.y = yy;						_btns.addChild(btn);						_btnArr.push(btn);												xx++;					}				}								_lines.alpha = _controller.gridAlpha/Constants.ALPHA_SLIDER_MAX_VAL;			}						_label = CustomTextField.getTextField("",0x000000,12);			_label.y = -1*Constants.GUTTER_WIDTH*1.5;			this.addChild(_label);						// default _controller.curSelectedButton to the first button			_controller.curSelectedButton = _btns.getChildAt(0) as OutlineButton;		}				public function getBMD():BitmapData		{			return _bmd;		}				public function updatePixels(selectedPal:Number, palArr:ByteArray, chrArr:ByteArray):void		{			_controller.curAttr = selectedPal;			_palArr = palArr;			_chrArr = chrArr;						// reselect the tile so we can update it to be on the right CHR page			_selectTile(false);						var xMax:Number = _w/16;			var yMax:Number = _h/16;						var tileCounter:Number = _controller.chrPage*0x0100;						for(var yDraw=0; yDraw<yMax; yDraw++)			{				for(var xDraw=0; xDraw<xMax; xDraw++)				{					_drawTile(xDraw, yDraw, tileCounter);					tileCounter++;				}			}						dispatchEvent( new CustomEvent(CustomEvent.UPDATE_BUFFER, {val:_namArr}) );		}				public function updatePixelsWithNam(selectedPal:Number, palArr:ByteArray, namArr:ByteArray, chrArr:ByteArray):void		{			//trace("updatedPixelsWithNam: selectedPal: " + selectedPal + ", palArr: " + palArr.length + ", namArr: " + namArr.length + ", chrArr: " + chrArr.length);			_controller.activeAttr = selectedPal;			_namArr = namArr;			_palArr = palArr;			_chrArr = chrArr;						var xMax:Number = _w/16;			var yMax:Number = _h/16;						var ntCounter:Number = 0;			for(var yDraw=0; yDraw<yMax; yDraw++)			{				for(var xDraw=0; xDraw<xMax; xDraw++)				{					_controller.curAttr = _getAttr(xDraw,yDraw);					_drawNamTile(xDraw, yDraw, namArr[ntCounter]);					ntCounter++;				}			}						dispatchEvent( new CustomEvent(CustomEvent.UPDATE_BUFFER, {val:_namArr}) );		}				public function updateLinesAlpha():void		{			_lines.alpha = _controller.gridAlpha/Constants.ALPHA_SLIDER_MAX_VAL;		}				public function setBackground(clr:Number):void		{			_bmd.lock();			_bmd.fillRect(new Rectangle(0,0,_w,_h), clr);			_bmd.unlock();		}				public function setBackgroundWithByte(clr:Number):void		{			var n:String = clr.toString(16).toUpperCase();			if(n.length < 2) n = "0"+n;						_bmd.lock();			_bmd.fillRect(new Rectangle(0,0,_w,_h), Constants["CLR_"+n]);			_bmd.unlock();		}				public function setChrBuffer(b:ByteArray):void		{			_chrArr = b;		}				public function setPalBuffer(b:ByteArray):void		{			_palArr = b;		}				public function setLabel(str:String):void		{			_label.text = str;		}				private function _getAttr(xx:Number, yy:Number):Number		{			var attrData = _namArr[960 + ((yy >> 2) * 8 + (xx >> 2))];			if ((yy & 2) > 0)			{				attrData >>= 4;			}			if ((xx & 2) > 0)			{				attrData >>= 2;			}						attrData &= 0x03;						return attrData;		}				private function _setAttr(xx:Number, yy:Number, attrPattern:Number):void		{		  var attrData:Number = 0x03;		  var attrMask:Number = 0x03;				  attrPattern &= 0x03;		  attrPattern |= attrPattern << 2;		  attrPattern |= attrPattern << 4;				  if ((yy & 2) > 0)		  {			attrMask <<= 4;		  }		  if ((xx & 2) > 0)		  {			attrMask <<= 2;		  }				  attrData = _namArr[960 + ((yy >> 2) * 8 + (xx >> 2))];		  attrData &= ~attrMask;		  attrData |= (attrPattern & attrMask);				  // Put it back :)		  _namArr[960 + ((yy >> 2) * 8 + (xx >> 2))] = attrData;		}				// Draw a 4x4 tile using the current nametable buffer - update buffer(s) FIRST then call this		private function _drawAttrSet(xx:Number, yy:Number):void		{			xx &= 0x1e;			yy &= 0x1e;					for (var i = 0; i < 2; i++)			{				for (var j = 0; j < 2; j++)				{					var tileNum:Number = _namArr[xx + i + ((yy + j) * 32)] + (0x0100 * _controller.chrPage);					_controller.curAttr = _getAttr(xx, yy);					_drawTile(xx + i, yy + j, tileNum);				}			}		}				private function _drawToGrid(xx:Number, yy:Number):void		{			// Update the buffer / current nametable to keep changes!			if(_controller.tileDraw)			{				_namArr[(xx >> 4) + ((yy >> 4) * (_w/16))] = _controller.selectedTile;			}			// If tile only mode is selected, skip altering the attribute table			if(_controller.palDraw)			{				_setAttr(xx >> 4, yy >> 4, _controller.activeAttr); //_controller.curAttr); this was preventing the attr data from updating			}					_drawAttrSet(xx >> 4, yy >> 4);						dispatchEvent( new CustomEvent(CustomEvent.UPDATE_BUFFER, {val:_namArr}) );		}				private function _sampleColor(xx:Number, yy:Number):void		{			xx >>= 4;			yy >>= 4;			_controller.selectedTile = _namArr[xx + (yy * (_w/16))] + (_controller.chrPage * 0x0100);			_controller.curAttr = _getAttr(xx, yy);						dispatchEvent( new CustomEvent(CustomEvent.COLOR_SAMPLE, {val:_controller.curAttr}) );		}				private function _selectTile(dispatch:Boolean = true):void		{			var xx:Number = _controller.curSelectedButton.x;			var yy:Number = _controller.curSelectedButton.y;						var coord:Point = new Point(xx,yy);			xx >>= 4;			yy >>= 4;			var tile = xx + (yy * 16) + (_controller.chrPage * 0x0100); 						 			_controller.selectedTile = tile;						if(dispatch) dispatchEvent( new CustomEvent(CustomEvent.BUTTON_UP) );		}				private function _drawTile(xPos:Number, yPos:Number, tileNum:Number):void		{			tileNum <<= 4;			xPos <<= 4;			yPos <<= 4;						_bmd.lock();			for(var i=tileNum; i<tileNum+8; i++)			{				var b0 = 0; //first bitplane;				var b1 = 0; // second bitplane;				b0 = _chrArr[i];   // first plane				b1 = _chrArr[i + 0x08];  // first plane + 8 bytes, stored in sequential, not interleaved format								for (var xx = 0; xx < 16; xx += 2)				{					var colorIndex:int = (((b0 & 0x80) >> 7) + ((b1 & 0x80) >> 6));					var n:int = colorIndex + (_controller.curAttr*4);					var s:String = _palArr[n].toString(16).toUpperCase();					if(s.length < 2) s = "0"+s;					var clr:int = Constants["CLR_"+s];										_bmd.setPixel(xPos + xx, yPos, clr);					_bmd.setPixel(xPos + xx + 1, yPos, clr);					_bmd.setPixel(xPos + xx, yPos + 1, clr);					_bmd.setPixel(xPos + xx + 1, yPos + 1, clr);										b0 <<= 1;					b1 <<= 1;				}								yPos += 2;			}			_bmd.unlock();			}				private function _drawNamTile(xPos:Number, yPos:Number, tileNum:Number):void		{			tileNum <<= 4;			xPos <<= 4;			yPos <<= 4;						_bmd.lock();			for(var i=tileNum; i<tileNum+8; i++)			{				var b0 = 0; //first bitplane;				var b1 = 0; // second bitplane;				b0 = _chrArr[i + (4096*_controller.chrPage)];   // first plane // no idea why we advance 4kb				b1 = _chrArr[i + (4096*_controller.chrPage) + 0x08];  // first plane + 8 bytes, stored in sequential, not interleaved format								for (var xx = 0; xx < 16; xx += 2)				{					var colorIndex:int = (((b0 & 0x80) >> 7) + ((b1 & 0x80) >> 6));					var n:int = colorIndex + (_controller.curAttr*4);					var s:String = _palArr[n].toString(16).toUpperCase();					if(s.length < 2) s = "0"+s;					var clr:int = Constants["CLR_"+s];										_bmd.setPixel(xPos + xx, yPos, clr);					_bmd.setPixel(xPos + xx + 1, yPos, clr);					_bmd.setPixel(xPos + xx, yPos + 1, clr);					_bmd.setPixel(xPos + xx + 1, yPos + 1, clr);										b0 <<= 1;					b1 <<= 1;				}								yPos += 2;			}			_bmd.unlock();			}				private function _onDragTimer($e:TimerEvent):void		{			_drawToGrid(mouseX, mouseY);		}				private function _onMouseDown($e:MouseEvent):void		{			var btn:OutlineButton = $e.currentTarget as OutlineButton;						if(_controller.curKey == 16)			{				_sampleColor(btn.x, btn.y);			}			else			{				if(!_dragTimer.running) 				{					_dragTimer.start();				}			}		}				private function _onMouseUp($e:MouseEvent):void		{			if(_w > 256) // this is the large namGrid			{				_dragTimer.stop();			}			else // this is the small chrGrid			{				// select tile with white outline				for(var i=0; i<_btnArr.length; i++)				{					var btn:OutlineButton = _btnArr[i] as OutlineButton;					btn.deselect();				}								var targetBtn:OutlineButton = $e.currentTarget as OutlineButton;				targetBtn.select();								// we save this here so we can keep a ref to the tile selected in the grid				// and can add the CHR page number to that so we can update where in the CHR we are				_controller.curSelectedButton = targetBtn;							// select the CHR data under the tile				_selectTile();			}		}				private function _onKeyUp($e:KeyboardEvent):void		{			_controller.curKey = 0;		}				private function _onKeyDown($e:KeyboardEvent):void		{			_controller.curKey = $e.keyCode;		}				public function destroy():void		{			this.removeChild(_bg);			_bg = null;			_controller = null;			this.removeChild(_lines);			while(_lines.numChildren > 0) _lines.removeChildAt(0);			_lines = null;			// clear btn arr		}	}}